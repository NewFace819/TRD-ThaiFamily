% Team Note Sample Template
% These codes should be guaranteed, fast enough, short and easy to type.

\documentclass[portrait, 8pt, a4paper, oneside, twocolumn]{extarticle}
\usepackage{teamnote}

% Uncomment below to use Korean
\usepackage{kotex}

\teamnote{VNU-HCM}{HCMUS - ThaiFamily}{Le Kien Thanh, Vo Thanh Hai, Do Gia Huy}

\ShowUsage
\ShowComplexity
\HideAuthor

\begin{document}

\maketitlepage

% Make Pagebreak if you want.
% \pagebreak 

\section{Misc}

\Algorithm{Generic Template}
{}{}
{cpp}{source/Misc/boiler_plate.cpp}

\Algorithm{FastIO}
{}{}
{cpp}{source/Misc/FastIO.cpp}

\Algorithm{Stress Tester}
{}{}
{batch}{source/Misc/StressTester.bat}

\Algorithm{Bench Marker}
{}{}
{batch}{source/Misc/Bench_Mark.bat}


\Algorithm{CP Sublime 3 Build}
{}{}
{batch}{source/Misc/CP.txt}

\Algorithm{CP Sublime 3 Keymap}
{}{}
{batch}{source/Misc/Default.txt}




\section {Data Structure}

\Algorithm{Convex Hull Trick}
{}{}
{cpp}{source/Data_Structure/convexhulltrick.cpp}

\Algorithm{Fast Segment Tree}
{}{}
{cpp}{source/Data_Structure/fast_seg_tree.cpp}

\Algorithm{Fast Segment Tree Lazy}
{}{}
{cpp}{source/Data_Structure/fast_seg_tree_lazy.cpp}

\Algorithm{Lichao Tree}
{}{}
{cpp}{source/Data_Structure/lichaotree.cpp}

\Algorithm{Persistent Segment Tree}
{}{}
{cpp}{source/Data_Structure/persistent_segmenttree.cpp}

\Algorithm{Treap}
{}{}
{cpp}{source/Data_Structure/treap.cpp}














\section {Geometry}

\Algorithm{Boiler Plate}
{}{}
{cpp}{source/Geometry/boiler_plate.cpp}

\Algorithm{Complex Numbers Utils}  % Tên hiển thị trong teamnote
{}{ }                               % Bạn có thể thêm chú thích / description nếu muốn
{cpp}{source/Geometry/complex.cpp}

\Algorithm{Manhattan Minimum Spanning Tree}{}{ }
{cpp}{source/Geometry/manhattan_spanning_tree.cpp}


\Algorithm{Smallest Enclosing Circle}
{}{}
{cpp}{source/Geometry/smallest_enclosing_circle.cpp}

\Algorithm{Circle vs CCW Polygon Intersection}
{}{}
{cpp}{source/Geometry/Circle_vs_CCW_Polygon_Intersection.cpp}

\Algorithm{Circle vs Line Intersect}
{}{}
{cpp}{source/Geometry/Circle_vs_Line_Intersect.cpp}

\Algorithm{Circles Intersect}
{}{}
{cpp}{source/Geometry/Circles_Intersect.cpp}

\Algorithm{Hull Diameter}
{}{}
{cpp}{source/Geometry/Hull_Diameter.cpp}

\Algorithm{Point in Poly}
{}{}
{cpp}{source/Geometry/Point_In_Poly.cpp}















\section{Graph}

\Algorithm{Block Cut Tree}
{}{}
{cpp}{source/Graph/block_cut_tree.cpp}

\Algorithm{Eulerian Path}
{}{}
{cpp}{source/Graph/eulerian_path.cpp}

\Algorithm{FLow With Demand}
{}{}
{cpp}{source/Graph/flow_with_demand.cpp}

\Algorithm{General Max Matching}
{}{}
{cpp}{source/Graph/general_max_matching.cpp}

\Algorithm{Max Flow}
{}{}
{cpp}{source/Graph/max_flow.cpp}

\Algorithm{Max Matching}
{}{}
{cpp}{source/Graph/max_matching.cpp}

\Algorithm{Min Cost Flow}
{}{}
{cpp}{source/Graph/min_cost_flow.cpp}

\Algorithm{Tarjan}
{}{}
{cpp}{source/Graph/tarjan.cpp}

\Algorithm{Two Sat}
{}{}
{cpp}{source/Graph/two_sat.cpp}

\section{String}

\Algorithm{Aho Corasick}
{}{}
{cpp}{source/String/Aho_Corasick.cpp}

\Algorithm{KMP}
{}{}
{cpp}{source/String/KMP.cpp}

\Algorithm{Palindrome Tree}
{}{}
{cpp}{source/String/Palindrome_tree.cpp}

\Algorithm{Suffix Array}
{}{}
{cpp}{source/String/Suffix_Array.cpp}

\Algorithm{Suffix Automaton}
{}{}
{cpp}{source/String/Suffix_Automaton.cpp}

\Algorithm{Z Function}
{}{}
{cpp}{source/String/ZFunction.cpp}

\section{Tree}

\Algorithm{Tree Line}
{}{}
{cpp}{source/Tree/treeline.cpp}






\section{Arithmetic}

\Algorithm{Extended GCD}
{}{}
{cpp}{source/Arithmetic/extended_gcd.cpp}

\Algorithm{Diophantine}
{}{}
{cpp}{source/Arithmetic/diophantine.cpp}


\Algorithm{Chinese Remainder Theorem}
{}{}
{cpp}{source/Arithmetic/chinese_remainder_theorem.cpp}



\Algorithm{Big Num Short}
{}{}
{cpp}{source/Arithmetic/short_big_num.cpp}

\Algorithm{Big Num Long}
{}{}
{cpp}{source/Arithmetic/big_num.cpp}

\Algorithm{Gaussian Elimination (Float)}
{}{}
{cpp}{source/Arithmetic/Gaussian_elimination.cpp}


\Algorithm{Gaussian Elimination (Integer)}
{}{}
{cpp}{source/Arithmetic/integer_gaussian.cpp}

\Algorithm{Miller Rabin}
{}{}
{cpp}{source/Arithmetic/miller_rabin.cpp}


\Algorithm{Pollard Rho}
{}{}
{cpp}{source/Arithmetic/Pollard_Rho.cpp}

\Algorithm{Lagrange Interpol}
{}{}
{cpp}{source/Arithmetic/lagrange_interpol.cpp}












\section{Combinatorics}

\Algorithm{FFT (Float)}
{}{}
{cpp}{source/Combinatorics/FFT.cpp}

\Algorithm{FFT (Integer)}
{}{}
{cpp}{source/Combinatorics/FFT-NTT.cpp}

\Algorithm{FFT + Poly Utilities}
{}{}
{cpp}{source/Combinatorics/Poly.cpp}

\Algorithm{Modular}
{}{}
{cpp}{source/Combinatorics/Modular.cpp}

\Algorithm{Matrix}
{}{}
{cpp}{source/Combinatorics/Matrix.cpp}

\Algorithm{Xor Convolution}
{}{}
{cpp}{source/Combinatorics/xor_convolution.cpp}

\end{document}
